<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | jedipunkz 🚀 のブログ</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - jedipunkz 🚀 のブログ">
<meta name="author" content="Theme PaperMod">
<link rel="canonical" href="https://jedipunkz.github.io/post/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.450f36617000261ed5ef323092a7c0037b2347dba027313b5a32ada072cab418.css" integrity="sha256-RQ82YXAAJh7V7zIwkqfAA3sjR9ugJzE7WjKtoHLKtBg=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://jedipunkz.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://jedipunkz.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jedipunkz.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://jedipunkz.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://jedipunkz.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://jedipunkz.github.io/post/index.xml">
<link rel="alternate" hreflang="en" href="https://jedipunkz.github.io/post/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><link rel="stylesheet" href="/css/custom.css">
<style>
 
.post-content code,
.post-content pre code,
.post-content .highlight code,
.post-content .highlighttable code {
    font-size: 1em !important;
}

 
.post-content p code,
.post-content li code,
.post-content td code {
    font-size: 1em !important;
}
</style>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-2H91XCYVZ8"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-2H91XCYVZ8');
        }
      </script><meta property="og:url" content="https://jedipunkz.github.io/post/">
  <meta property="og:site_name" content="jedipunkz 🚀 のブログ">
  <meta property="og:title" content="Posts">
  <meta property="og:description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="website">
      <meta property="og:image" content="https://jedipunkz.github.io/jedipunkz.jpg">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://jedipunkz.github.io/jedipunkz.jpg">
<meta name="twitter:title" content="Posts">
<meta name="twitter:description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://jedipunkz.github.io/post/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jedipunkz.github.io/" accesskey="h" title="jedipunkz 🚀 のブログ (Alt + H)">jedipunkz 🚀 のブログ</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jedipunkz.github.io/about" title="About Me">
                    <span>About Me</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>Posts</h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>k8s コンテナをインクリメンタルサーチ&amp;ログインする kubectl プラグインの開発
    </h2>
  </header>
  <section class="entry-content">
    <p>こんにちは。jedipunkz です。
今回は、kubectl プラグインを開発したことがなかったので、Go の学習と合わせてためしに1つ作ってみたのでその内容を記したいと思います。
開発した kubectl plugin: kubectl-fuzzy-login 下記が今回開発した kubectl プラグインです。
https://github.com/jedipunkz/kubectl-fuzzy-login
何が出来るか 下記のキャプチャをご覧頂くと一目瞭然だと思います。
Kubernetes のポッドとコンテナをインクリメンタルサーチしつつ選択し、最終的にコンテナにログイン出来るプラグインになっています。コンテナがサイドカー構成になっていた場合は、そのうちのどのコンテナにログインするかもインクリメンタルサーチ出来ます。なお、このプラグインは Go で開発しました。
インストール方法 Krew を利用している場合は下記の操作でインストールできます。Krew が事前にインストールされている必要があります。
git clone https://github.com/jedipunkz/kubectl-fuzzy-login.git kubectl krew install --manifest=./kubectl-fuzzy-login/krew/fuzzy-login.yaml マニュアル操作でインストールする場合は下記です。
git clone https://github.com/jedipunkz/kubectl-fuzzy-login.git cd kubectl-fuzzy-login go build cp kubectl-fuzzy-login /your/bin/path 使用方法 オプション無しで、全 Namespaces を対象に検索・ログインする オプションを使用しない場合は下記のように実行します。
kubectl fuzzy login まず Pod を選択します。Pod 名の一部を入力することでインクリメンタル・ファジー検索出来ます。その Pod に複数のコンテナ (サイドカー) がある場合、更にコンテナをインクリメンタルサーチ出来ます。最終的にコンテナを選択し Enter ボタンを押すことでコンテナにログイン出来ます。ただしコンテナイメージにシェルが入っていない場合は入ることが出来ません。
シェル指定 また下記のように -s オプションでデフォルトのシェルを指定することもできます。
kubectl fuzzy login -s /bin/bash Namespace 指定 Namespace を -n オプションで指定することもできます。
...</p>
  </section>
  
  <a class="entry-link" aria-label="post link to k8s コンテナをインクリメンタルサーチ&ログインする kubectl プラグインの開発" href="https://jedipunkz.github.io/post/kubectl-plugin/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>手軽にローカルで Argo Rollouts, Istio, Prometheus で Progressive Delivery を試す
    </h2>
  </header>
  <section class="entry-content">
    <p>こんにちは。jedipunkz🚀 です。
以前こちらの PipeCD 検証の記事 で Progressive Deliver について調査したのですが、Kubernetes でこの Progressive Delivery を実現する方法を調べておきたいなと思って手元の Macbook 上で検証してみたのでその際の手順を記そうかと思います。
Progressive Delivery の概要 ここで概要だけ記しておきます。Canary リリースは新しいデプロイメントをある程度の割合だけリリースし、徐々にリリースを進行させるデプロイ方式ということはご存知だと思いますが、Progressive Delivery はその過程で
新しいデプロイメントの統計情報を得る 予め定義したデプロイ成功定義に対して条件満たしているかを過程毎にチェックする チェック OK であれば次の過程にデプロイを進める 予め定義した幾つかのデプロイ過程を全て終えるとデプロイ完了となる というステップを経ます。
用いるソフトウェア Kubernetes で Progressive Delivery を実現するには下記のソフトウェアを用いる事が可能です。 また今回の手順は MacOS を前提に記します。
Argo Rollouts Prometheus Istio Kubernetes (今回は Minikube を使いました) 事前の準備 Istio Istio をダウンロードします。
curl -L https://istio.io/downloadIstio | ISTIO_VERSION=17.2 sh - Istio を Minikube にデプロイします。
cd istio-17.2 istioctl install --set profile=demo -y Kubernetes Namespace default で起動した Pod が自動的に Envoy サイドカーを取得するように設定します。
...</p>
  </section>
  
  <a class="entry-link" aria-label="post link to 手軽にローカルで Argo Rollouts, Istio, Prometheus で Progressive Delivery を試す" href="https://jedipunkz.github.io/post/argo-rollout-progressive-delivery/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>自前ツールと Cloudwatch 高解像度メトリクスを使ったより高速な ECS オートスケールの実現
    </h2>
  </header>
  <section class="entry-content">
    <p>こんにちは @jedipunkz 🚀 です。
普段仕事で AWS ECS を使っていて Autoscallng Group によってアプリケーションを据えケールさせて運用していますが、運用している中でより高速にオートスケール出来ないものだろうか？と思うシチュエーションが何回か発生し、対応方法について模索していました。
実際に発生したシチュエーション 下記はコンテナ毎の CPU 使用率です。1分未満の間に急激にアクセスが増えコンテナの CPU 使用率が 100% に達し (実際には vCPU に基づいて 200% となっている)、ECS Service のヘルスチェックに Fail して、コンテナが落ち、新しいコンテナは起動するものの、アクセス不可に耐えられず、コンテナ停止と起動を繰り返すといった状況でした。
Autoscaling Policy, Cloudwatch Metrics Alarm の調整 まず最初に考えたのが下記の値の調整です。
aws_app_autoscaling_policy の cooldown 値 aws_cloudwatch_metric_alarm の period 値 具体的には 60sec となっていた値を 10sec などに変更しました。これによって 60sec のインターバルでしきい値計算してスケールさせていたところを 10sec にインターバルを縮めつつスケールさせる。つまりより迅速にスケールさせることで上記のシチュエーションに耐えられるのではと考えました。
ですが、結果は NG でした。
下記は Cloudwatch Metrics の様子です。データはプロットされているものの、データ不足 という状態に陥っている事がわかります。
実際に ECS はこの設定をした Metrics Alarm ではスケールしてくれませんでした。
高解像度メトリクスの利用について であれば高解像度メトリクス を利用すれば良いのではと考えました。
...</p>
  </section>
  
  <a class="entry-link" aria-label="post link to 自前ツールと Cloudwatch 高解像度メトリクスを使ったより高速な ECS オートスケールの実現" href="https://jedipunkz.github.io/post/esp/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Sysdig&#43;ECS Fargate でコンテナランタイムセキュリティ実践
    </h2>
  </header>
  <section class="entry-content">
    <p>こんにちは @jedipunkz 🚀 です。
ECS 構成をもう少しセキュアに保てる構成はないものだろうかと模索しているなかで Sysdig を見つけました。まだ導入できる目処は立っていないのですがある程度ノウハウ蓄積出来てきたのでここで検証内容等を記事にしようかと思っています。
Sysdig は幾つかのサービスが存在するのですが今回検証したのは Sysdig Serverless Security と呼ばれるモノで ECS Fargate 上のコンテナランタイムセキュリティを実践することができるサービスです。
Sysdig とは AWS のサービスにも脅威検知を行うことができるサービスが揃っているのはご存知と思います
対象 目的 技術・サービス AWS リソース 驚異検知 AWS GuardDuty また予防の観点で脆弱性診断が出来るサービスもありあす
対象 目的 技術・サービス AWS リソース セキュリティ診断 AWS Trusted Advisor ECS コンテナ 脆弱性診断 ECR Image Scan EC2 上のソフトウェア 脆弱性診断 AWS Inspector ここで気がつくと思うのですがコンテナ上の驚異検知を行うサービスが AWS には無いと思っています。 (2022/09 時点)
Sysdig Serverless Security は ECS Fargate コンテナ上の脅威検知を行うサービスです。ECS Fargate 利用時にコンテナ上の脅威検知を行うサービスは他にも幾つかありますが、Sysdig はシステムコールを利用したコンテナランタイムセキュリティを実践して脅威検知・通知が行えるものになります。自分も詳しくないのですがこれを CWPP (Cloud Workload Protection Platform) と言うらしいです。ワークロードというのはクラウド上の仮想マシン・稼働中のソフトウェアを指して、CWPP はマルウェア保護、脆弱性スキャン、アクセス制御、異常検知の機能を使用してそれぞれのワークロードを保護する、ということらしいです。
...</p>
  </section>
  
  <a class="entry-link" aria-label="post link to Sysdig&#43;ECS Fargate でコンテナランタイムセキュリティ実践" href="https://jedipunkz.github.io/post/sysdig-ecs-fargate/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>ECS &#43; PipeCD &#43; Datadog でプログレッシブデリバリーを実現
    </h2>
  </header>
  <section class="entry-content">
    <p>こんにちは @jedipunkz 🚀 です。
今回は CNCF にジョインした PipeCD と Datadog を用いて ECS 環境にてプログレッシブデリバリーを実現する方法について調査したので、その内容を記したいと思います。
そもそもプログレッシブデリバリーとは アプリケーションのデリバリー方法はカナリーリリースやブルーグリーンデプロイメント等がよく知られていると思います。プログレッシブデリバリーはその一歩先を行くデリバリー方式で、Prometheus や Datadog 等のメトリクスを用いて SLO (SRE の SLO と言うよりはデプロイのための指標という意味での) を元にカナリーリリースしたアプリケーションが期待した動作をしているかを確認し (プログレッシブデリバリー的にはこのフェーズを ANALYSIS という様です)、その上でカナリーリリースを完了するというフローになります。
構成 Pipecd, Piped 共に Kubernetes (EKS) クラスタ上に起動する構成 この検証ではこちらの構成を選択しました。この構成の特徴は
piped は pipecd の API エンドポイントを指し示す pipecd は UI を提供 pipecd は Filestore (S3, GCS, Minio など), Datastore (MySQL, Firestore など) を利用可 (今回は Minio, MySQL を選択) piped は Target Group, ECS タスク定義等の操作を行うため ECS API へのアクセス権限が必要 piped の pipeline 上のステージで ANALYSIS という Datadog 等のメトリクスを解析する機能を有している アプリケーションレポジトリには app.pipecd.yaml を配置しターゲットグループ・タスク定義・ECS サービスを指し示す piped は GitHub レポジトリを参照 となっています。
...</p>
  </section>
  
  <a class="entry-link" aria-label="post link to ECS &#43; PipeCD &#43; Datadog でプログレッシブデリバリーを実現" href="https://jedipunkz.github.io/post/ecs-pipecd/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>ECR 脆弱性スキャン結果表示 CLI の開発と Datadog プロット
    </h2>
  </header>
  <section class="entry-content">
    <p>こんにちは。jedipunkz🚀 です。
引き続き Go を学習しています。前回の記事 ECS コンテナにログインする CLI を Go 言語で作った話 のまとめにも記したのですが Go のコードを書くアイデアとして下記をぼんやり考えていました。
ECR 脆弱性スキャンのパッケージを開発 そのパッケージを利用して Datadog のカスタムメトリクスとして送信 同様にそのパッケージを利用して ECR スキャンの CLI を作成 その紹介を軽くしたいと思います。
開発した ECR 脆弱性スキャンの Go パッケージ 開発したパッケージは https://github.com/jedipunkz/ecrscan になります。
下記のように Ecr 構造体を初期化します。
e := myecr.Ecr{} e.Repositories = [][]string{ {&#34;image-to-scan&#34;, &#34;latest&#34;}, } e.Resion = &#34;ap-northeast-1&#34; finding, vulFindings, _ := e.ListFindings() その後 ListFindings() メソッドでスキャンします。結果、finding.FindingSeverityCounts には下記の深刻度毎のイメージに含まれている脆弱性の数が入ります。
INFORMATIONAL LOW MEDIUM HIGH CRITICAL UNDEFINED また、vulFindings には含まれている脆弱性の
CVE 名 深刻度レベル (INFORMATIONAL, LOW, MEDIUM, HIGH, CRITICAL, UNDEFINED) CVE URI 説明 が入ります。
...</p>
  </section>
  
  <a class="entry-link" aria-label="post link to ECR 脆弱性スキャン結果表示 CLI の開発と Datadog プロット" href="https://jedipunkz.github.io/post/ecr-scan-datadog-go/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>ECS コンテナにログインする CLI を Go 言語で作った話
    </h2>
  </header>
  <section class="entry-content">
    <p>こんにちは @jedipunkz 🚀 です。
今回は Go 言語で ECS コンテナにログインする CLI を作った話を書きます。
開発の経緯 自分はまだ Go 言語の初学者で学習のために開発するアイデアを探していた状態でした。そこで自分の勤めている会社で ECS Execute 機能を使ったコンテナログインの機能を開発者に提供していた事を思い出し色々調べていて「もう少し手間が省けないか？」と思い立った、という経緯で開発をはじめました。
awscli を使った ECS Execute 機能によるコンテナログイン 手間が多いと書きましたが実際に awscli を使う場合どの程度の手間があるのか簡単に記します。まず下記のコマンドを実行して
$ aws ecs list-tasks --cluster &lt;クラスタ名&gt; --service &lt;サービス名&gt; taskArn が得られるので Arn から task ID を拾って、その task ID を使って
$ aws ecs execute --cluster &lt;クラスタ名&gt; \ --task &lt;task ID&gt; \ -- container &lt;コンテナ名&gt; \ --interfactive \ --command &#34;sh&#34; とコマンドを実行することでコンテナにログイン出来ます。が手間が少し多いのと task ID を拾い出す作業も辛いので改善したい…。
操作画面 ということで miniecs という CLI を作ったのですが、 まずは操作している様子を貼り付けます。😷 Fuzzy Finder なインクリメンタルサーチが出来る CLI になっていて、ECS クラスタ名・ECS サービス名・コンテナ名を一部入力するとログインしたい環境が選択出来るツールになっています。
...</p>
  </section>
  
  <a class="entry-link" aria-label="post link to ECS コンテナにログインする CLI を Go 言語で作った話" href="https://jedipunkz.github.io/post/ecs-login-cli/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>App Mesh と ECS によるカナリーリリース構成を検証してみた
    </h2>
  </header>
  <section class="entry-content">
    <p>こんにちは。jedipunkz🚀 です。
今回も READYFOR Advent Calendar 2021 の記事として執筆します。
今回のテーマ 前回の記事 では ECS 移行後の構成について検討する内容を記しました。Progressive Delivery を実践する上でもその一歩手前の構成と言っていいカナリーリリース構成について、今回は記していきたいと思います。
デグレしてしまっていたカナリーリリース READYFOR では AWS ECS 移行を行い ECS &#43; CodeDeploy による Blue/Green デプロイメントを導入しました。逆に移行前までに出来ていたカナリーリリースが実施できなくなりました。とは言ってもそれまで開発者がカナリーリリースに対して求めていた主な機能はロールバックだったため、ひとまずは Blue/Green デプロイメントで事足りている状況なのですが、今後大きな機能をリリースする際にはトラヒックを徐々に寄せ影響を把握した上でリリース進めるという作業は必要になってくる可能性があります。
よって、
Progressive Delivery の一歩手前の構成を実践する 大きなリリースのための環境整備 という意味でも、一回カナリーリリース構成について検討しておこうと考えました。
環境構築 今回用意した Terraform コード 検証で作成した AWS 環境をデプロイするための Terraform コードを下記の場所に置いてあります。参考にしてください。
https://github.com/jedipunkz/tf-appmesh-ecs-canary-release
(今回検証で作成したコードは業務上作成したものですが、READYFOR の OSS ポリシーに則り著作権譲渡をうけており、自らのGitHubリポジトリで公開しています。)
App Mesh ECS NLB Service Discovery Envoy X-Ray といった技術要素で構成されています。
Terraform コードによるデプロイ実施 上記に記した Terraform コードを使った構成のデプロイ手順を記します。
前提として Terraform バージョン 1.0.x 系以上をローカルにインストールする必要があります。
$ # AWS クレデンシャル情報を設定 $ git clone https://github.com/jedipunkz/tf-appmesh-ecs-canary-release $ cd tf-appmesh-ecs-canary-release $ terraform plan $ terraform apply 構成 検証で構築した構成(上記の Terraform コードで構築できる) は下記になります。
...</p>
  </section>
  
  <a class="entry-link" aria-label="post link to App Mesh と ECS によるカナリーリリース構成を検証してみた" href="https://jedipunkz.github.io/post/app-mesh-ecs-canary/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://jedipunkz.github.io/post/">« Prev</a>
    <a class="next" href="https://jedipunkz.github.io/post/page/3/">Next »</a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://jedipunkz.github.io/">jedipunkz 🚀 のブログ</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
