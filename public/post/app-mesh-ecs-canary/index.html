<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>App Mesh と ECS によるカナリーリリース構成を検証してみた | jedipunkz 🚀 のブログ</title>
<meta name="keywords" content="">
<meta name="description" content="こんにちは。jedipunkz🚀 です。
今回も READYFOR Advent Calendar 2021 の記事として執筆します。
今回のテーマ
前回の記事 では ECS 移行後の構成について検討する内容を記しました。Progressive Delivery を実践する上でもその一歩手前の構成と言っていいカナリーリリース構成について、今回は記していきたいと思います。
デグレしてしまっていたカナリーリリース
READYFOR では AWS ECS 移行を行い ECS &#43; CodeDeploy による Blue/Green デプロイメントを導入しました。逆に移行前までに出来ていたカナリーリリースが実施できなくなりました。とは言ってもそれまで開発者がカナリーリリースに対して求めていた主な機能はロールバックだったため、ひとまずは Blue/Green デプロイメントで事足りている状況なのですが、今後大きな機能をリリースする際にはトラヒックを徐々に寄せ影響を把握した上でリリース進めるという作業は必要になってくる可能性があります。
よって、

Progressive Delivery の一歩手前の構成を実践する
大きなリリースのための環境整備

という意味でも、一回カナリーリリース構成について検討しておこうと考えました。
環境構築
今回用意した Terraform コード
検証で作成した AWS 環境をデプロイするための Terraform コードを下記の場所に置いてあります。参考にしてください。
https://github.com/jedipunkz/tf-appmesh-ecs-canary-release
(今回検証で作成したコードは業務上作成したものですが、READYFOR の OSS ポリシーに則り著作権譲渡をうけており、自らのGitHubリポジトリで公開しています。)

App Mesh
ECS
NLB
Service Discovery
Envoy
X-Ray

といった技術要素で構成されています。
Terraform コードによるデプロイ実施
上記に記した Terraform コードを使った構成のデプロイ手順を記します。
前提として Terraform バージョン 1.0.x 系以上をローカルにインストールする必要があります。
$ # AWS クレデンシャル情報を設定
$ git clone https://github.com/jedipunkz/tf-appmesh-ecs-canary-release
$ cd tf-appmesh-ecs-canary-release
$ terraform plan
$ terraform apply
構成
検証で構築した構成(上記の Terraform コードで構築できる) は下記になります。">
<meta name="author" content="Theme PaperMod">
<link rel="canonical" href="https://jedipunkz.github.io/post/app-mesh-ecs-canary/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.25e364bfdd34a1094a67b649147da19d4f5a4f0ccffe1fb4546255b3733d5680.css" integrity="sha256-JeNkv900oQlKZ7ZJFH2hnU9aTwzP/h&#43;0VGJVs3M9VoA=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://jedipunkz.github.io/pix/jedipunkz.jpg">
<link rel="icon" type="image/png" sizes="16x16" href="https://jedipunkz.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jedipunkz.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://jedipunkz.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://jedipunkz.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://jedipunkz.github.io/post/app-mesh-ecs-canary/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><script async src="https://www.googletagmanager.com/gtag/js?id="></script>
<script>
	window.dataLayer = window.dataLayer || [];
	function gtag() {
		dataLayer.push(arguments);
	}
	gtag("js", new Date());

	gtag("config", "");
</script>
<meta property="og:url" content="https://jedipunkz.github.io/post/app-mesh-ecs-canary/">
  <meta property="og:site_name" content="jedipunkz 🚀 のブログ">
  <meta property="og:title" content="App Mesh と ECS によるカナリーリリース構成を検証してみた">
  <meta property="og:description" content="こんにちは。jedipunkz🚀 です。
今回も READYFOR Advent Calendar 2021 の記事として執筆します。
今回のテーマ 前回の記事 では ECS 移行後の構成について検討する内容を記しました。Progressive Delivery を実践する上でもその一歩手前の構成と言っていいカナリーリリース構成について、今回は記していきたいと思います。
デグレしてしまっていたカナリーリリース READYFOR では AWS ECS 移行を行い ECS &#43; CodeDeploy による Blue/Green デプロイメントを導入しました。逆に移行前までに出来ていたカナリーリリースが実施できなくなりました。とは言ってもそれまで開発者がカナリーリリースに対して求めていた主な機能はロールバックだったため、ひとまずは Blue/Green デプロイメントで事足りている状況なのですが、今後大きな機能をリリースする際にはトラヒックを徐々に寄せ影響を把握した上でリリース進めるという作業は必要になってくる可能性があります。
よって、
Progressive Delivery の一歩手前の構成を実践する 大きなリリースのための環境整備 という意味でも、一回カナリーリリース構成について検討しておこうと考えました。
環境構築 今回用意した Terraform コード 検証で作成した AWS 環境をデプロイするための Terraform コードを下記の場所に置いてあります。参考にしてください。
https://github.com/jedipunkz/tf-appmesh-ecs-canary-release
(今回検証で作成したコードは業務上作成したものですが、READYFOR の OSS ポリシーに則り著作権譲渡をうけており、自らのGitHubリポジトリで公開しています。)
App Mesh ECS NLB Service Discovery Envoy X-Ray といった技術要素で構成されています。
Terraform コードによるデプロイ実施 上記に記した Terraform コードを使った構成のデプロイ手順を記します。
前提として Terraform バージョン 1.0.x 系以上をローカルにインストールする必要があります。
$ # AWS クレデンシャル情報を設定 $ git clone https://github.com/jedipunkz/tf-appmesh-ecs-canary-release $ cd tf-appmesh-ecs-canary-release $ terraform plan $ terraform apply 構成 検証で構築した構成(上記の Terraform コードで構築できる) は下記になります。">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2021-12-10T13:56:56+09:00">
    <meta property="article:modified_time" content="2021-12-10T13:56:56+09:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="App Mesh と ECS によるカナリーリリース構成を検証してみた">
<meta name="twitter:description" content="こんにちは。jedipunkz🚀 です。
今回も READYFOR Advent Calendar 2021 の記事として執筆します。
今回のテーマ
前回の記事 では ECS 移行後の構成について検討する内容を記しました。Progressive Delivery を実践する上でもその一歩手前の構成と言っていいカナリーリリース構成について、今回は記していきたいと思います。
デグレしてしまっていたカナリーリリース
READYFOR では AWS ECS 移行を行い ECS &#43; CodeDeploy による Blue/Green デプロイメントを導入しました。逆に移行前までに出来ていたカナリーリリースが実施できなくなりました。とは言ってもそれまで開発者がカナリーリリースに対して求めていた主な機能はロールバックだったため、ひとまずは Blue/Green デプロイメントで事足りている状況なのですが、今後大きな機能をリリースする際にはトラヒックを徐々に寄せ影響を把握した上でリリース進めるという作業は必要になってくる可能性があります。
よって、

Progressive Delivery の一歩手前の構成を実践する
大きなリリースのための環境整備

という意味でも、一回カナリーリリース構成について検討しておこうと考えました。
環境構築
今回用意した Terraform コード
検証で作成した AWS 環境をデプロイするための Terraform コードを下記の場所に置いてあります。参考にしてください。
https://github.com/jedipunkz/tf-appmesh-ecs-canary-release
(今回検証で作成したコードは業務上作成したものですが、READYFOR の OSS ポリシーに則り著作権譲渡をうけており、自らのGitHubリポジトリで公開しています。)

App Mesh
ECS
NLB
Service Discovery
Envoy
X-Ray

といった技術要素で構成されています。
Terraform コードによるデプロイ実施
上記に記した Terraform コードを使った構成のデプロイ手順を記します。
前提として Terraform バージョン 1.0.x 系以上をローカルにインストールする必要があります。
$ # AWS クレデンシャル情報を設定
$ git clone https://github.com/jedipunkz/tf-appmesh-ecs-canary-release
$ cd tf-appmesh-ecs-canary-release
$ terraform plan
$ terraform apply
構成
検証で構築した構成(上記の Terraform コードで構築できる) は下記になります。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://jedipunkz.github.io/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "App Mesh と ECS によるカナリーリリース構成を検証してみた",
      "item": "https://jedipunkz.github.io/post/app-mesh-ecs-canary/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "App Mesh と ECS によるカナリーリリース構成を検証してみた",
  "name": "App Mesh と ECS によるカナリーリリース構成を検証してみた",
  "description": "こんにちは。jedipunkz🚀 です。\n今回も READYFOR Advent Calendar 2021 の記事として執筆します。\n今回のテーマ 前回の記事 では ECS 移行後の構成について検討する内容を記しました。Progressive Delivery を実践する上でもその一歩手前の構成と言っていいカナリーリリース構成について、今回は記していきたいと思います。\nデグレしてしまっていたカナリーリリース READYFOR では AWS ECS 移行を行い ECS + CodeDeploy による Blue/Green デプロイメントを導入しました。逆に移行前までに出来ていたカナリーリリースが実施できなくなりました。とは言ってもそれまで開発者がカナリーリリースに対して求めていた主な機能はロールバックだったため、ひとまずは Blue/Green デプロイメントで事足りている状況なのですが、今後大きな機能をリリースする際にはトラヒックを徐々に寄せ影響を把握した上でリリース進めるという作業は必要になってくる可能性があります。\nよって、\nProgressive Delivery の一歩手前の構成を実践する 大きなリリースのための環境整備 という意味でも、一回カナリーリリース構成について検討しておこうと考えました。\n環境構築 今回用意した Terraform コード 検証で作成した AWS 環境をデプロイするための Terraform コードを下記の場所に置いてあります。参考にしてください。\nhttps://github.com/jedipunkz/tf-appmesh-ecs-canary-release\n(今回検証で作成したコードは業務上作成したものですが、READYFOR の OSS ポリシーに則り著作権譲渡をうけており、自らのGitHubリポジトリで公開しています。)\nApp Mesh ECS NLB Service Discovery Envoy X-Ray といった技術要素で構成されています。\nTerraform コードによるデプロイ実施 上記に記した Terraform コードを使った構成のデプロイ手順を記します。\n前提として Terraform バージョン 1.0.x 系以上をローカルにインストールする必要があります。\n$ # AWS クレデンシャル情報を設定 $ git clone https://github.com/jedipunkz/tf-appmesh-ecs-canary-release $ cd tf-appmesh-ecs-canary-release $ terraform plan $ terraform apply 構成 検証で構築した構成(上記の Terraform コードで構築できる) は下記になります。\n",
  "keywords": [
    
  ],
  "articleBody": "こんにちは。jedipunkz🚀 です。\n今回も READYFOR Advent Calendar 2021 の記事として執筆します。\n今回のテーマ 前回の記事 では ECS 移行後の構成について検討する内容を記しました。Progressive Delivery を実践する上でもその一歩手前の構成と言っていいカナリーリリース構成について、今回は記していきたいと思います。\nデグレしてしまっていたカナリーリリース READYFOR では AWS ECS 移行を行い ECS + CodeDeploy による Blue/Green デプロイメントを導入しました。逆に移行前までに出来ていたカナリーリリースが実施できなくなりました。とは言ってもそれまで開発者がカナリーリリースに対して求めていた主な機能はロールバックだったため、ひとまずは Blue/Green デプロイメントで事足りている状況なのですが、今後大きな機能をリリースする際にはトラヒックを徐々に寄せ影響を把握した上でリリース進めるという作業は必要になってくる可能性があります。\nよって、\nProgressive Delivery の一歩手前の構成を実践する 大きなリリースのための環境整備 という意味でも、一回カナリーリリース構成について検討しておこうと考えました。\n環境構築 今回用意した Terraform コード 検証で作成した AWS 環境をデプロイするための Terraform コードを下記の場所に置いてあります。参考にしてください。\nhttps://github.com/jedipunkz/tf-appmesh-ecs-canary-release\n(今回検証で作成したコードは業務上作成したものですが、READYFOR の OSS ポリシーに則り著作権譲渡をうけており、自らのGitHubリポジトリで公開しています。)\nApp Mesh ECS NLB Service Discovery Envoy X-Ray といった技術要素で構成されています。\nTerraform コードによるデプロイ実施 上記に記した Terraform コードを使った構成のデプロイ手順を記します。\n前提として Terraform バージョン 1.0.x 系以上をローカルにインストールする必要があります。\n$ # AWS クレデンシャル情報を設定 $ git clone https://github.com/jedipunkz/tf-appmesh-ecs-canary-release $ cd tf-appmesh-ecs-canary-release $ terraform plan $ terraform apply 構成 検証で構築した構成(上記の Terraform コードで構築できる) は下記になります。\n構成の特徴とリクエスト処理の流れ NLB で受け付けた TCP 80 番ポートのリクエストを ECS Task 上で起動している Envoy (Gateway) にリクエスト分散 Envoy (Gateway) はトラヒックを AppMesh Virtual Gateway のルーティング先に指定している VirtualService へ分散 VirtualService には VirtualRouter が設定されておりルーティング情報として VirtualNode x 2 台を設定している 結果 VirtualNode x 2 “example1”, “example2” へ荷重ルーティングによってトラヒックがルーティングされる 各 VirtualNode は ECS Task (example1, example2) に紐付いている ※example1, example2 は上記 Terraform コード内で設定している AWS リソース名です。\nサービスディスカバリの構成 AWS ServiceDiscovery を用いてサービスディスカバリの機能を用いています。名前の関係については下記になります。\nNamespace として example.internal を作成 (CloudMap として生成される) Namespace example.internal 配下に exmaplegw.example.internal をサービスディスカバリサービスとして生成 Namespace example.internal 配下に exmaple1.example.internal をサービスディスカバリサービスとして生成 Namespace example.internal 配下に exmaple2.example.internal をサービスディスカバリサービスとして生成 また、各サービスディスカバリサービスはヘルスチェックの機能を有していて、実体である ECS Task が無いと Route53 レコードは生成されません。\n動作確認 構築した App Mesh + ECS 構成の動作確認をしてみます。\n下記の App Mesh Route の記述 にある通り、各 VirtualNode (exmaple1, example2) への荷重ルーティングとして 95:5 という比率を設定しています。\nspec { http_route { match { prefix = \"/\" } action { weighted_target { virtual_node = aws_appmesh_virtual_node.example1.name weight = 95 } weighted_target { virtual_node = aws_appmesh_virtual_node.example2.name weight = 5 } } } } この設定した比率 95:5 が機能しているかを確認するため、下記のような簡単なスクリプトを用意して実行してみます。\n#!/bin/sh i=0 while [ $i -ne 100 ] do i=$(($i+1)) echo \"$i\" curl http://\u003e /tmp/example.log sleep 1 done 結果として下記のに 97:3 という比率でそれぞれの VirtualNode (ECS Task) から応答があり、App Mesh Route の設定値 95:5 とほぼ同等である事が判りました。\n$ grep example1 /tmp/example.log | wc -l 97 $ grep example2 /tmp/example.log | wc -l 3 aws-sdk-go を使った荷重ルーティング操作について READYFOR ではインフラのコードを Go 言語を使って開発する機会が多いのですが、ここでは aws-sdk-go を使った荷重ルーティング操作について調べたので記していきます。\nなぜ aws-sdk-go なのか？ 荷重ルーティングは App Mesh の VirtualRoute というルーティング設定に設定を施すのですが、それ自体が AWS リソースです。よって Terraform コードでリソース作成したのですが、SRE やインフラメンバと異なり、開発者自身にカナリーリリースを実践してもらう 事を想定すると Terraform コードによる操作は不向きと考えました。よって他の方法を考えなくてはいけません。\nSRE の持っている権限と機能を開発者に提供するという意味では Slack 等のコミュニケーションツールの入力によるボット操作が非常に融和性が高いと考えています。よって、このボットを開発する上でも aws-sdk-go を使って荷重ルーティング操作が出来てしまえば、あとは開発するだけとなります。\n参考資料 aws-sdk-go の荷重ルーティング操作については下記の関数を利用します。\nhttps://docs.aws.amazon.com/sdk-for-go/api/service/appmesh/#AppMesh.UpdateRoute\n荷重ルーティング操作コード 下記に動作確認まで行った Go のコードを記します。 UpdateRoute メソッドを実行するだけで操作が行えました。UpdateRouteInput に環境情報を記しつつ、Spec に荷重設定値を入力する事で荷重ルーティングを操作できることが分かります。\npackage main import ( \"encoding/json\" \"fmt\" \"log\" \"github.com/aws/aws-sdk-go/aws\" \"github.com/aws/aws-sdk-go/aws/session\" \"github.com/aws/aws-sdk-go/service/appmesh\" ) func main() { sess := session.New() svc := appmesh.New(sess) jsonBlob := []byte(` { \"HttpRoute\": { \"Action\": { \"WeightedTargets\": [{ \"VirtualNode\": \"example1\", \"Weight\": 90 },{ \"VirtualNode\": \"example2\", \"Weight\": 10 }] }, \"Match\": { \"Prefix\": \"/\" } } }`) var spec *appmesh.RouteSpec err := json.Unmarshal(jsonBlob, \u0026spec) if err != nil { log.Fatal(err) } input := \u0026appmesh.UpdateRouteInput{ // ClientToken: aws.String(\"foo\"), MeshName: aws.String(\"example\"), MeshOwner: aws.String(\"\"), RouteName: aws.String(\"example\"), Spec: spec, VirtualRouterName: aws.String(\"example\"), } result, err := svc.UpdateRoute(input) if err != nil { log.Println(err) } fmt.Println(result) } まとめと考察 結果として下記のことが分かりました。\nApp Mesh + ECS の最小構成が組め、カナリーリリース機能を開発者へ提供できる 操作自体も開発者自身に行ってもらえる ですが、幾つかか考えなくてはいけない事があります。\n問題点 一方の VirualNode A (仮の名前として用います) からもう一方の VirtualNode B へカナリーリリースを実施すると通常時にリクエストを受ける環境は VirtualNode B とります。その次のリリースタイミングでは逆に VirtualNode B -\u003e VirtualNode A と切り替えなくてはいけないのか？またアプリケーションのデプロイワークフローの対象リソースが A なのか B なのか、という問題が浮上してきます。\nこれらが解決できないと、運用負担増やトラブルシュートの難易度高といった受け入れがたい具体的な問題に繋がると考えています。\n問題点の解消: 構成案 #1 そこで上記の問題を回避しつつどう構成するかを考えてみました。\n前提の環境 下記の前提で構成を考えてみます。\nVirtualNode A を通常時にサービスを受ける ECS Service として用意 VirtualNode B をカナリーリリース時のサービスを受ける ECS Service として用意 ブランチと ECS Service の対応 レポジトリのブランチ main , canary に対して下記のような対応付けで ECS Service をデプロイする戦略です。\nブランチ名 デプロイ先の ECS Serivice main ECS Service (VIrtualNode A) canary ECS Service (VirtualNode B) リリースの流れ リリースの流れとしては下記が考えれます。\n(1) canary ブランチにマージ \u0026 VirtualNode B ECS へデプロイ (2) 荷重ルーティングにより A -\u003e B へ徐々にトラヒックを流し最終的に 100% に (3) main ブランチにマージして VirtualNode A ECS へデプロイ (4) 荷重ルーティング A:B = 100:0 として VirtualNode A ECS へ 100% 流す これにより、VirtualNode A は通常時用 ECS 環境という前提を守ることが出来ます。また、A -\u003e B, B -\u003e A とカナリーリリースの流れの向きを切り替える問題も解消されます。\nただ、これは一案であって、他にも良い構成が考えられるかもしれません。\n今回紹介した構成以外の構成について 今回は検証しなかったのですが、VirtualNode の backend 設定が可能なようです。詳細はこちらの Terraform ドキュメント にあります。これによって下記のような流れが組めると想定しています。\nNLB -\u003e VirtualGateway (ECS) -\u003e VirtualSerivce α -\u003e VirtualRoute α -\u003e VirtualNod α (ECS) x n -\u003e VirtualService β -\u003e VirtualRouter β -\u003e VirtualNode β (ECS) x n ロードバランサなのかサービスディスカバリなのかの考察 ロードバランサとサービスディスカバリが提供できる機能は\n冗長性 保守性 拡張性 という意味ではほぼ同等の機能を有していると考えています。なのでより枯れた技術であるロードバランサを使って構成を考えられないか検討してみました。\n結果、VirtualNode -\u003e SerivceDiscovery -\u003e ECS Service と連携する際に ECS Service は ServiceDiscovery 自体をレジスト出来るので上記の構成図の様な構成が組めるのですが、ロードバランサにすると、ECS Service に当てはめられるのは LB となります。荷重ルーティング・カナリーリリースをする際に ECS Service が複数必要なわけですが、そうすると ECS Service の数分の LB が必要になります。もちろんそれを構成する TargetGroup, Listenr (ListenrRule) も必要になります。\n尚、その際には Virtual Node の Service Discovery の dns パラメータに hostname だけを記して、LB の DNS 名を知るせば良さそうに見受けました。が、この構成については無駄なリソースが発生すると判断したことを受け、検証未実施です。\nservice_discovery { dns { hostname = \"nlb-****.example.internal\" } } これは同等の機能を提供してくれる ServiceDiscovery を使ったほうが無駄な aws リソースを作らなくて済む、という結果につながります。\nまとめのまとめ(所感) 以上、ECS を使ったカナリーリリース構成について記しました。個人的には導入の前に Envoy や X-ray についてもう少し情報収集して調査の解像度を上げていく必要があると感じています。すべてのリクエストのトラヒックが Envoy コンテナを介す事になり、それらの知識が十分に無いと万が一のトラブルシュートの際に困るだろうなぁと考えています。\n",
  "wordCount" : "646",
  "inLanguage": "en",
  "datePublished": "2021-12-10T13:56:56+09:00",
  "dateModified": "2021-12-10T13:56:56+09:00",
  "author":{
    "@type": "Person",
    "name": "Theme PaperMod"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://jedipunkz.github.io/post/app-mesh-ecs-canary/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "jedipunkz 🚀 のブログ",
    "logo": {
      "@type": "ImageObject",
      "url": "https://jedipunkz.github.io/pix/jedipunkz.jpg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jedipunkz.github.io/" accesskey="h" title="jedipunkz 🚀 のブログ (Alt + H)">jedipunkz 🚀 のブログ</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jedipunkz.github.io/about" title="About Me">
                    <span>About Me</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      App Mesh と ECS によるカナリーリリース構成を検証してみた
    </h1>
    
  </header> 
  <div class="post-content"><p>こんにちは。<a href="https://twitter.com/jedipunkz">jedipunkz🚀</a> です。</p>
<p>今回も <a href="https://qiita.com/advent-calendar/2021/readyfor">READYFOR Advent Calendar 2021</a> の記事として執筆します。</p>
<h2 id="今回のテーマ">今回のテーマ<a hidden class="anchor" aria-hidden="true" href="#今回のテーマ">#</a></h2>
<p><a href="https://jedipunkz.github.io/post/progressive_delivery/">前回の記事</a> では ECS 移行後の構成について検討する内容を記しました。Progressive Delivery を実践する上でもその一歩手前の構成と言っていいカナリーリリース構成について、今回は記していきたいと思います。</p>
<h3 id="デグレしてしまっていたカナリーリリース">デグレしてしまっていたカナリーリリース<a hidden class="anchor" aria-hidden="true" href="#デグレしてしまっていたカナリーリリース">#</a></h3>
<p>READYFOR では AWS ECS 移行を行い ECS + CodeDeploy による Blue/Green デプロイメントを導入しました。逆に移行前までに出来ていたカナリーリリースが実施できなくなりました。とは言ってもそれまで開発者がカナリーリリースに対して求めていた主な機能はロールバックだったため、ひとまずは Blue/Green デプロイメントで事足りている状況なのですが、今後大きな機能をリリースする際にはトラヒックを徐々に寄せ影響を把握した上でリリース進めるという作業は必要になってくる可能性があります。</p>
<p>よって、</p>
<ul>
<li>Progressive Delivery の一歩手前の構成を実践する</li>
<li>大きなリリースのための環境整備</li>
</ul>
<p>という意味でも、一回カナリーリリース構成について検討しておこうと考えました。</p>
<h2 id="環境構築">環境構築<a hidden class="anchor" aria-hidden="true" href="#環境構築">#</a></h2>
<h3 id="今回用意した-terraform-コード">今回用意した Terraform コード<a hidden class="anchor" aria-hidden="true" href="#今回用意した-terraform-コード">#</a></h3>
<p>検証で作成した AWS 環境をデプロイするための Terraform コードを下記の場所に置いてあります。参考にしてください。</p>
<p><a href="https://github.com/jedipunkz/tf-appmesh-ecs-canary-release">https://github.com/jedipunkz/tf-appmesh-ecs-canary-release</a></p>
<p>(今回検証で作成したコードは業務上作成したものですが、READYFOR の OSS ポリシーに則り著作権譲渡をうけており、自らのGitHubリポジトリで公開しています。)</p>
<ul>
<li>App Mesh</li>
<li>ECS</li>
<li>NLB</li>
<li>Service Discovery</li>
<li>Envoy</li>
<li>X-Ray</li>
</ul>
<p>といった技術要素で構成されています。</p>
<h3 id="terraform-コードによるデプロイ実施">Terraform コードによるデプロイ実施<a hidden class="anchor" aria-hidden="true" href="#terraform-コードによるデプロイ実施">#</a></h3>
<p>上記に記した Terraform コードを使った構成のデプロイ手順を記します。</p>
<p>前提として Terraform バージョン 1.0.x 系以上をローカルにインストールする必要があります。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ <span style="color:#75715e"># AWS クレデンシャル情報を設定</span>
</span></span><span style="display:flex;"><span>$ git clone https://github.com/jedipunkz/tf-appmesh-ecs-canary-release
</span></span><span style="display:flex;"><span>$ cd tf-appmesh-ecs-canary-release
</span></span><span style="display:flex;"><span>$ terraform plan
</span></span><span style="display:flex;"><span>$ terraform apply
</span></span></code></pre></div><h3 id="構成">構成<a hidden class="anchor" aria-hidden="true" href="#構成">#</a></h3>
<p>検証で構築した構成(上記の Terraform コードで構築できる) は下記になります。</p>
<img src="http://jedipunkz.github.io/pix/appmesh_ecs.png" width="100%">
<h4 id="構成の特徴とリクエスト処理の流れ">構成の特徴とリクエスト処理の流れ<a hidden class="anchor" aria-hidden="true" href="#構成の特徴とリクエスト処理の流れ">#</a></h4>
<ul>
<li>NLB で受け付けた TCP 80 番ポートのリクエストを ECS Task 上で起動している Envoy (Gateway) にリクエスト分散</li>
<li>Envoy (Gateway) はトラヒックを AppMesh Virtual Gateway のルーティング先に指定している VirtualService へ分散</li>
<li>VirtualService には VirtualRouter が設定されておりルーティング情報として VirtualNode x 2 台を設定している</li>
<li>結果 VirtualNode x 2 &ldquo;example1&rdquo;, &ldquo;example2&rdquo; へ荷重ルーティングによってトラヒックがルーティングされる</li>
<li>各 VirtualNode は ECS Task (example1, example2) に紐付いている</li>
</ul>
<p>※example1, example2 は上記 Terraform コード内で設定している AWS リソース名です。</p>
<h4 id="サービスディスカバリの構成">サービスディスカバリの構成<a hidden class="anchor" aria-hidden="true" href="#サービスディスカバリの構成">#</a></h4>
<p>AWS ServiceDiscovery を用いてサービスディスカバリの機能を用いています。名前の関係については下記になります。</p>
<ul>
<li>Namespace として <code>example.internal</code> を作成 (CloudMap として生成される)</li>
<li>Namespace <code>example.internal</code> 配下に <code>exmaplegw.example.internal</code> をサービスディスカバリサービスとして生成</li>
<li>Namespace <code>example.internal</code> 配下に <code>exmaple1.example.internal</code> をサービスディスカバリサービスとして生成</li>
<li>Namespace <code>example.internal</code> 配下に <code>exmaple2.example.internal</code> をサービスディスカバリサービスとして生成</li>
</ul>
<p>また、各サービスディスカバリサービスはヘルスチェックの機能を有していて、実体である ECS Task が無いと Route53 レコードは生成されません。</p>
<h2 id="動作確認">動作確認<a hidden class="anchor" aria-hidden="true" href="#動作確認">#</a></h2>
<p>構築した App Mesh + ECS 構成の動作確認をしてみます。</p>
<p><a href="https://github.com/jedipunkz/tf-appmesh-ecs-canary-release/blob/main/appmesh.tf#L73-L91">下記の App Mesh Route の記述</a> にある通り、各 VirtualNode (exmaple1, example2) への荷重ルーティングとして <code>95:5</code> という比率を設定しています。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hcl" data-lang="hcl"><span style="display:flex;"><span>  <span style="color:#66d9ef">spec</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">http_route</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">match</span> {
</span></span><span style="display:flex;"><span>        prefix <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;/&#34;</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">action</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">weighted_target</span> {
</span></span><span style="display:flex;"><span>          virtual_node <span style="color:#f92672">=</span> <span style="color:#66d9ef">aws_appmesh_virtual_node</span>.<span style="color:#66d9ef">example1</span>.<span style="color:#66d9ef">name</span>
</span></span><span style="display:flex;"><span>          weight       <span style="color:#f92672">=</span> <span style="color:#ae81ff">95</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">weighted_target</span> {
</span></span><span style="display:flex;"><span>          virtual_node <span style="color:#f92672">=</span> <span style="color:#66d9ef">aws_appmesh_virtual_node</span>.<span style="color:#66d9ef">example2</span>.<span style="color:#66d9ef">name</span>
</span></span><span style="display:flex;"><span>          weight       <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>この設定した比率 95:5 が機能しているかを確認するため、下記のような簡単なスクリプトを用意して実行してみます。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/sh
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#f92672">[</span> $i -ne <span style="color:#ae81ff">100</span> <span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">do</span>
</span></span><span style="display:flex;"><span>        i<span style="color:#f92672">=</span><span style="color:#66d9ef">$((</span>$i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span><span style="color:#66d9ef">))</span>
</span></span><span style="display:flex;"><span>        echo <span style="color:#e6db74">&#34;</span>$i<span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>        curl http://&lt;NLB の DNS 名/ &gt;&gt; /tmp/example.log
</span></span><span style="display:flex;"><span>        sleep <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">done</span>
</span></span></code></pre></div><p>結果として下記のに <code>97:3</code> という比率でそれぞれの VirtualNode (ECS Task) から応答があり、App Mesh Route の設定値 <code>95:5</code> とほぼ同等である事が判りました。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>$ grep example1 /tmp/example.log | wc -l
</span></span><span style="display:flex;"><span>      <span style="color:#ae81ff">97</span>
</span></span><span style="display:flex;"><span>$ grep example2 /tmp/example.log | wc -l
</span></span><span style="display:flex;"><span>       <span style="color:#ae81ff">3</span>
</span></span></code></pre></div><h2 id="aws-sdk-go-を使った荷重ルーティング操作について">aws-sdk-go を使った荷重ルーティング操作について<a hidden class="anchor" aria-hidden="true" href="#aws-sdk-go-を使った荷重ルーティング操作について">#</a></h2>
<p>READYFOR ではインフラのコードを Go 言語を使って開発する機会が多いのですが、ここでは aws-sdk-go を使った荷重ルーティング操作について調べたので記していきます。</p>
<h3 id="なぜ-aws-sdk-go-なのか">なぜ aws-sdk-go なのか？<a hidden class="anchor" aria-hidden="true" href="#なぜ-aws-sdk-go-なのか">#</a></h3>
<p>荷重ルーティングは App Mesh の VirtualRoute というルーティング設定に設定を施すのですが、それ自体が AWS リソースです。よって Terraform コードでリソース作成したのですが、SRE やインフラメンバと異なり、開発者自身にカナリーリリースを実践してもらう 事を想定すると Terraform コードによる操作は不向きと考えました。よって他の方法を考えなくてはいけません。</p>
<p>SRE の持っている権限と機能を開発者に提供するという意味では Slack 等のコミュニケーションツールの入力によるボット操作が非常に融和性が高いと考えています。よって、このボットを開発する上でも aws-sdk-go を使って荷重ルーティング操作が出来てしまえば、あとは開発するだけとなります。</p>
<h3 id="参考資料">参考資料<a hidden class="anchor" aria-hidden="true" href="#参考資料">#</a></h3>
<p>aws-sdk-go の荷重ルーティング操作については下記の関数を利用します。</p>
<p><a href="https://docs.aws.amazon.com/sdk-for-go/api/service/appmesh/#AppMesh.UpdateRoute">https://docs.aws.amazon.com/sdk-for-go/api/service/appmesh/#AppMesh.UpdateRoute</a></p>
<h3 id="荷重ルーティング操作コード">荷重ルーティング操作コード<a hidden class="anchor" aria-hidden="true" href="#荷重ルーティング操作コード">#</a></h3>
<p>下記に動作確認まで行った Go のコードを記します。
UpdateRoute メソッドを実行するだけで操作が行えました。UpdateRouteInput に環境情報を記しつつ、<code>Spec</code> に荷重設定値を入力する事で荷重ルーティングを操作できることが分かります。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;encoding/json&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;github.com/aws/aws-sdk-go/aws&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;github.com/aws/aws-sdk-go/aws/session&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#e6db74">&#34;github.com/aws/aws-sdk-go/service/appmesh&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">sess</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">session</span>.<span style="color:#a6e22e">New</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">svc</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">appmesh</span>.<span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">sess</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">jsonBlob</span> <span style="color:#f92672">:=</span> []byte(<span style="color:#e6db74">`
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		&#34;HttpRoute&#34;: {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">			&#34;Action&#34;: {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">				&#34;WeightedTargets&#34;: [{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">					&#34;VirtualNode&#34;: &#34;example1&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">					&#34;Weight&#34;: 90
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">				},{
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">					&#34;VirtualNode&#34;: &#34;example2&#34;,
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">					&#34;Weight&#34;: 10
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">				}]
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">			},
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">			&#34;Match&#34;: {
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">				&#34;Prefix&#34;: &#34;/&#34;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">			}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">		}
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">	}`</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">spec</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">appmesh</span>.<span style="color:#a6e22e">RouteSpec</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">json</span>.<span style="color:#a6e22e">Unmarshal</span>(<span style="color:#a6e22e">jsonBlob</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">spec</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Fatal</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">input</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">appmesh</span>.<span style="color:#a6e22e">UpdateRouteInput</span>{
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// ClientToken: aws.String(&#34;foo&#34;),</span>
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">MeshName</span>:          <span style="color:#a6e22e">aws</span>.<span style="color:#a6e22e">String</span>(<span style="color:#e6db74">&#34;example&#34;</span>),
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">MeshOwner</span>:         <span style="color:#a6e22e">aws</span>.<span style="color:#a6e22e">String</span>(<span style="color:#e6db74">&#34;&lt;AWS アカウント ID&gt;&#34;</span>),
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">RouteName</span>:         <span style="color:#a6e22e">aws</span>.<span style="color:#a6e22e">String</span>(<span style="color:#e6db74">&#34;example&#34;</span>),
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Spec</span>:              <span style="color:#a6e22e">spec</span>,
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">VirtualRouterName</span>: <span style="color:#a6e22e">aws</span>.<span style="color:#a6e22e">String</span>(<span style="color:#e6db74">&#34;example&#34;</span>),
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">result</span>, <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">svc</span>.<span style="color:#a6e22e">UpdateRoute</span>(<span style="color:#a6e22e">input</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">log</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">result</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="まとめと考察">まとめと考察<a hidden class="anchor" aria-hidden="true" href="#まとめと考察">#</a></h2>
<p>結果として下記のことが分かりました。</p>
<ul>
<li>App Mesh + ECS の最小構成が組め、カナリーリリース機能を開発者へ提供できる</li>
<li>操作自体も開発者自身に行ってもらえる</li>
</ul>
<p>ですが、幾つかか考えなくてはいけない事があります。</p>
<h3 id="問題点">問題点<a hidden class="anchor" aria-hidden="true" href="#問題点">#</a></h3>
<p>一方の VirualNode A (仮の名前として用います) からもう一方の VirtualNode B へカナリーリリースを実施すると通常時にリクエストを受ける環境は VirtualNode B とります。その次のリリースタイミングでは逆に VirtualNode B -&gt; VirtualNode A と切り替えなくてはいけないのか？またアプリケーションのデプロイワークフローの対象リソースが A なのか B なのか、という問題が浮上してきます。</p>
<p>これらが解決できないと、運用負担増やトラブルシュートの難易度高といった受け入れがたい具体的な問題に繋がると考えています。</p>
<h3 id="問題点の解消-構成案-1">問題点の解消: 構成案 #1<a hidden class="anchor" aria-hidden="true" href="#問題点の解消-構成案-1">#</a></h3>
<p>そこで上記の問題を回避しつつどう構成するかを考えてみました。</p>
<h4 id="前提の環境">前提の環境<a hidden class="anchor" aria-hidden="true" href="#前提の環境">#</a></h4>
<p>下記の前提で構成を考えてみます。</p>
<ul>
<li>VirtualNode A を通常時にサービスを受ける ECS Service として用意</li>
<li>VirtualNode B をカナリーリリース時のサービスを受ける ECS Service として用意</li>
</ul>
<h4 id="ブランチと-ecs-service-の対応">ブランチと ECS Service の対応<a hidden class="anchor" aria-hidden="true" href="#ブランチと-ecs-service-の対応">#</a></h4>
<p>レポジトリのブランチ <code>main</code> , <code>canary</code> に対して下記のような対応付けで ECS Service をデプロイする戦略です。</p>
<table>
  <thead>
      <tr>
          <th>ブランチ名</th>
          <th>デプロイ先の ECS Serivice</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>main</td>
          <td>ECS Service (VIrtualNode A)</td>
      </tr>
      <tr>
          <td>canary</td>
          <td>ECS Service (VirtualNode B)</td>
      </tr>
  </tbody>
</table>
<h4 id="リリースの流れ">リリースの流れ<a hidden class="anchor" aria-hidden="true" href="#リリースの流れ">#</a></h4>
<p>リリースの流れとしては下記が考えれます。</p>
<ul>
<li>(1) <code>canary</code> ブランチにマージ &amp; VirtualNode B ECS へデプロイ</li>
<li>(2) 荷重ルーティングにより A -&gt; B へ徐々にトラヒックを流し最終的に 100% に</li>
<li>(3) <code>main</code> ブランチにマージして VirtualNode A ECS へデプロイ</li>
<li>(4) 荷重ルーティング A:B = 100:0 として VirtualNode A ECS へ 100% 流す</li>
</ul>
<p>これにより、VirtualNode A は通常時用 ECS 環境という前提を守ることが出来ます。また、A -&gt; B, B -&gt; A とカナリーリリースの流れの向きを切り替える問題も解消されます。</p>
<p>ただ、これは一案であって、他にも良い構成が考えられるかもしれません。</p>
<h3 id="今回紹介した構成以外の構成について">今回紹介した構成以外の構成について<a hidden class="anchor" aria-hidden="true" href="#今回紹介した構成以外の構成について">#</a></h3>
<p>今回は検証しなかったのですが、VirtualNode の backend 設定が可能なようです。詳細は<a href="https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/appmesh_virtual_node#backend">こちらの Terraform ドキュメント</a> にあります。これによって下記のような流れが組めると想定しています。</p>
<pre tabindex="0"><code>NLB -&gt; VirtualGateway (ECS) -&gt; VirtualSerivce α -&gt; VirtualRoute α -&gt; VirtualNod α (ECS) x n -&gt; VirtualService β -&gt; VirtualRouter β -&gt; VirtualNode β (ECS) x n
</code></pre><h3 id="ロードバランサなのかサービスディスカバリなのかの考察">ロードバランサなのかサービスディスカバリなのかの考察<a hidden class="anchor" aria-hidden="true" href="#ロードバランサなのかサービスディスカバリなのかの考察">#</a></h3>
<p>ロードバランサとサービスディスカバリが提供できる機能は</p>
<ul>
<li>冗長性</li>
<li>保守性</li>
<li>拡張性</li>
</ul>
<p>という意味ではほぼ同等の機能を有していると考えています。なのでより枯れた技術であるロードバランサを使って構成を考えられないか検討してみました。</p>
<p>結果、VirtualNode -&gt; SerivceDiscovery -&gt; ECS Service と連携する際に ECS Service は ServiceDiscovery 自体をレジスト出来るので上記の構成図の様な構成が組めるのですが、ロードバランサにすると、ECS Service に当てはめられるのは LB となります。荷重ルーティング・カナリーリリースをする際に ECS Service が複数必要なわけですが、そうすると ECS Service の数分の LB が必要になります。もちろんそれを構成する TargetGroup, Listenr (ListenrRule) も必要になります。</p>
<p>尚、その際には Virtual Node の Service Discovery の dns パラメータに hostname だけを記して、LB の DNS 名を知るせば良さそうに見受けました。が、この構成については無駄なリソースが発生すると判断したことを受け、検証未実施です。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-hcl" data-lang="hcl"><span style="display:flex;"><span>    <span style="color:#66d9ef">service_discovery</span> {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">dns</span> {
</span></span><span style="display:flex;"><span>        hostname <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;nlb-****.example.internal&#34;</span>
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>これは同等の機能を提供してくれる ServiceDiscovery を使ったほうが無駄な aws リソースを作らなくて済む、という結果につながります。</p>
<h3 id="まとめのまとめ所感">まとめのまとめ(所感)<a hidden class="anchor" aria-hidden="true" href="#まとめのまとめ所感">#</a></h3>
<p>以上、ECS を使ったカナリーリリース構成について記しました。個人的には導入の前に Envoy や X-ray についてもう少し情報収集して調査の解像度を上げていく必要があると感じています。すべてのリクエストのトラヒックが Envoy コンテナを介す事になり、それらの知識が十分に無いと万が一のトラブルシュートの際に困るだろうなぁと考えています。</p>


  </div>

  <footer class="post-footer">

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share App Mesh と ECS によるカナリーリリース構成を検証してみた on x"
            href="https://x.com/intent/tweet/?text=App%20Mesh%20%e3%81%a8%20ECS%20%e3%81%ab%e3%82%88%e3%82%8b%e3%82%ab%e3%83%8a%e3%83%aa%e3%83%bc%e3%83%aa%e3%83%aa%e3%83%bc%e3%82%b9%e6%a7%8b%e6%88%90%e3%82%92%e6%a4%9c%e8%a8%bc%e3%81%97%e3%81%a6%e3%81%bf%e3%81%9f&amp;url=https%3a%2f%2fjedipunkz.github.io%2fpost%2fapp-mesh-ecs-canary%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share App Mesh と ECS によるカナリーリリース構成を検証してみた on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjedipunkz.github.io%2fpost%2fapp-mesh-ecs-canary%2f&amp;title=App%20Mesh%20%e3%81%a8%20ECS%20%e3%81%ab%e3%82%88%e3%82%8b%e3%82%ab%e3%83%8a%e3%83%aa%e3%83%bc%e3%83%aa%e3%83%aa%e3%83%bc%e3%82%b9%e6%a7%8b%e6%88%90%e3%82%92%e6%a4%9c%e8%a8%bc%e3%81%97%e3%81%a6%e3%81%bf%e3%81%9f&amp;summary=App%20Mesh%20%e3%81%a8%20ECS%20%e3%81%ab%e3%82%88%e3%82%8b%e3%82%ab%e3%83%8a%e3%83%aa%e3%83%bc%e3%83%aa%e3%83%aa%e3%83%bc%e3%82%b9%e6%a7%8b%e6%88%90%e3%82%92%e6%a4%9c%e8%a8%bc%e3%81%97%e3%81%a6%e3%81%bf%e3%81%9f&amp;source=https%3a%2f%2fjedipunkz.github.io%2fpost%2fapp-mesh-ecs-canary%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share App Mesh と ECS によるカナリーリリース構成を検証してみた on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fjedipunkz.github.io%2fpost%2fapp-mesh-ecs-canary%2f&title=App%20Mesh%20%e3%81%a8%20ECS%20%e3%81%ab%e3%82%88%e3%82%8b%e3%82%ab%e3%83%8a%e3%83%aa%e3%83%bc%e3%83%aa%e3%83%aa%e3%83%bc%e3%82%b9%e6%a7%8b%e6%88%90%e3%82%92%e6%a4%9c%e8%a8%bc%e3%81%97%e3%81%a6%e3%81%bf%e3%81%9f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share App Mesh と ECS によるカナリーリリース構成を検証してみた on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjedipunkz.github.io%2fpost%2fapp-mesh-ecs-canary%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share App Mesh と ECS によるカナリーリリース構成を検証してみた on whatsapp"
            href="https://api.whatsapp.com/send?text=App%20Mesh%20%e3%81%a8%20ECS%20%e3%81%ab%e3%82%88%e3%82%8b%e3%82%ab%e3%83%8a%e3%83%aa%e3%83%bc%e3%83%aa%e3%83%aa%e3%83%bc%e3%82%b9%e6%a7%8b%e6%88%90%e3%82%92%e6%a4%9c%e8%a8%bc%e3%81%97%e3%81%a6%e3%81%bf%e3%81%9f%20-%20https%3a%2f%2fjedipunkz.github.io%2fpost%2fapp-mesh-ecs-canary%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share App Mesh と ECS によるカナリーリリース構成を検証してみた on telegram"
            href="https://telegram.me/share/url?text=App%20Mesh%20%e3%81%a8%20ECS%20%e3%81%ab%e3%82%88%e3%82%8b%e3%82%ab%e3%83%8a%e3%83%aa%e3%83%bc%e3%83%aa%e3%83%aa%e3%83%bc%e3%82%b9%e6%a7%8b%e6%88%90%e3%82%92%e6%a4%9c%e8%a8%bc%e3%81%97%e3%81%a6%e3%81%bf%e3%81%9f&amp;url=https%3a%2f%2fjedipunkz.github.io%2fpost%2fapp-mesh-ecs-canary%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share App Mesh と ECS によるカナリーリリース構成を検証してみた on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=App%20Mesh%20%e3%81%a8%20ECS%20%e3%81%ab%e3%82%88%e3%82%8b%e3%82%ab%e3%83%8a%e3%83%aa%e3%83%bc%e3%83%aa%e3%83%aa%e3%83%bc%e3%82%b9%e6%a7%8b%e6%88%90%e3%82%92%e6%a4%9c%e8%a8%bc%e3%81%97%e3%81%a6%e3%81%bf%e3%81%9f&u=https%3a%2f%2fjedipunkz.github.io%2fpost%2fapp-mesh-ecs-canary%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://jedipunkz.github.io/">jedipunkz 🚀 のブログ</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
