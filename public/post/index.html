<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | jedipunkz 🚀 のブログ</title>
<meta name="keywords" content="" />
<meta name="description" content="Posts - jedipunkz 🚀 のブログ">
<meta name="author" content="Theme PaperMod">
<link rel="canonical" href="https://jedipunkz.github.io/post/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.3ee8503a5e4652ff8c44c6ca20ea063c510259d67dab9cb99eb4c969bccfc06d.css" integrity="sha256-PuhQOl5GUv&#43;MRMbKIOoGPFECWdZ9q5y5nrTJabzPwG0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://jedipunkz.github.io/pix/jedipunkz.jpg">
<link rel="icon" type="image/png" sizes="16x16" href="https://jedipunkz.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jedipunkz.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://jedipunkz.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://jedipunkz.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.121.1">
<link rel="alternate" type="application/rss+xml" href="https://jedipunkz.github.io/post/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-30563095-1', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="Posts" />
<meta property="og:description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://jedipunkz.github.io/post/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://jedipunkz.github.io/post/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jedipunkz.github.io" accesskey="h" title="jedipunkz 🚀 のブログ (Alt + H)">jedipunkz 🚀 のブログ</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jedipunkz.github.io/about" title="About Me">
                    <span>About Me</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>Posts</h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>VyOS で IPoE/PPPoE を併用して安定した接続&amp;サーバー公開
    </h2>
  </header>
  <section class="entry-content">
    <p>@jedipunkz です。今まで自宅では PPPoE 接続をして Global IPv4 アドレスを取得して自宅にマイクラサーバーを外部公開しその接続を使って各端末でオンラインゲームやインターネットをしていました。ただ、IPoE 接続すると混雑時間を回避出来ると聞いていたので (これについては後術します)、普段のゲームや各端末のインターネット接続は IPoE 接続を利用しマイクラサーバーは PPPoE で公開、と出来ないかと考えました。IPoE は IPv4 over IPv6 のトンネリング接続するたため IPoE だけでは IPv4 Global IP アドレスによるサーバー公開は不可能だからです。
ここでは VyOS を使ってその両者を満たす接続の設定方法を記します。
要件 PPPoE して Global IPv4 を取得しサーバーを外部に提供 (その際に Dynamic DNS を利用 (自宅は Cloudflare)) サーバー以外の端末のトラヒックは IPoE 接続した経路に流す 回線はNTT フレッツ想定 (自分の場合は Asahi-net, IPv6 接続オプションあり, その他でも可) ISO イメージをビルド VyOS は Stable のバージョンは有償バージョンでないとダウンロード出来ませんがビルドすれば ISO イメージが作れます。その方法を記します。
2023/12 時点で最新の Stable バージョン 1.3.4 を指定 適当な Linux 端末でビルドしましたが Docker を利用できればどこでも良さそう git clone -b equuleus https://github....</p>
  </section>
  <footer class="entry-footer">&lt;span title=&#39;2023-12-10 01:14:57 &#43;0900 JST&#39;&gt;December 10, 2023&lt;/span&gt;&amp;nbsp;·&amp;nbsp;5 min&amp;nbsp;·&amp;nbsp;Theme PaperMod</footer>
  <a class="entry-link" aria-label="post link to VyOS で IPoE/PPPoE を併用して安定した接続&amp;サーバー公開" href="https://jedipunkz.github.io/post/vyos-ipoe-pppoe/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>k8s コンテナをインクリメンタルサーチ&amp;ログインする kubectl プラグインの開発
    </h2>
  </header>
  <section class="entry-content">
    <p>こんにちは。jedipunkz です。
今回は、kubectl プラグインを開発したことがなかったので、Go の学習と合わせてためしに1つ作ってみたのでその内容を記したいと思います。
開発した kubectl plugin: kubectl-fuzzy-login 下記が今回開発した kubectl プラグインです。
https://github.com/jedipunkz/kubectl-fuzzy-login
何が出来るか 下記のキャプチャをご覧頂くと一目瞭然だと思います。
Kubernetes のポッドとコンテナをインクリメンタルサーチしつつ選択し、最終的にコンテナにログイン出来るプラグインになっています。コンテナがサイドカー構成になっていた場合は、そのうちのどのコンテナにログインするかもインクリメンタルサーチ出来ます。なお、このプラグインは Go で開発しました。
インストール方法 Krew を利用している場合は下記の操作でインストールできます。Krew が事前にインストールされている必要があります。
git clone https://github.com/jedipunkz/kubectl-fuzzy-login.git kubectl krew install --manifest=./kubectl-fuzzy-login/krew/fuzzy-login.yaml マニュアル操作でインストールする場合は下記です。
git clone https://github.com/jedipunkz/kubectl-fuzzy-login.git cd kubectl-fuzzy-login go build cp kubectl-fuzzy-login /your/bin/path 使用方法 オプション無しで、全 Namespaces を対象に検索・ログインする オプションを使用しない場合は下記のように実行します。
kubectl fuzzy login まず Pod を選択します。Pod 名の一部を入力することでインクリメンタル・ファジー検索出来ます。その Pod に複数のコンテナ (サイドカー) がある場合、更にコンテナをインクリメンタルサーチ出来ます。最終的にコンテナを選択し Enter ボタンを押すことでコンテナにログイン出来ます。ただしコンテナイメージにシェルが入っていない場合は入ることが出来ません。
シェル指定 また下記のように -s オプションでデフォルトのシェルを指定することもできます。
kubectl fuzzy login -s /bin/bash Namespace 指定 Namespace を -n オプションで指定することもできます。...</p>
  </section>
  <footer class="entry-footer">&lt;span title=&#39;2023-06-16 23:28:09 &#43;0900 JST&#39;&gt;June 16, 2023&lt;/span&gt;&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;Theme PaperMod</footer>
  <a class="entry-link" aria-label="post link to k8s コンテナをインクリメンタルサーチ&amp;ログインする kubectl プラグインの開発" href="https://jedipunkz.github.io/post/kubectl-plugin/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>手軽にローカルで Argo Rollouts, Istio, Prometheus で Progressive Delivery を試す
    </h2>
  </header>
  <section class="entry-content">
    <p>こんにちは。jedipunkz🚀 です。
以前こちらの PipeCD 検証の記事 で Progressive Deliver について調査したのですが、Kubernetes でこの Progressive Delivery を実現する方法を調べておきたいなと思って手元の Macbook 上で検証してみたのでその際の手順を記そうかと思います。
Progressive Delivery の概要 ここで概要だけ記しておきます。Canary リリースは新しいデプロイメントをある程度の割合だけリリースし、徐々にリリースを進行させるデプロイ方式ということはご存知だと思いますが、Progressive Delivery はその過程で
新しいデプロイメントの統計情報を得る 予め定義したデプロイ成功定義に対して条件満たしているかを過程毎にチェックする チェック OK であれば次の過程にデプロイを進める 予め定義した幾つかのデプロイ過程を全て終えるとデプロイ完了となる というステップを経ます。
用いるソフトウェア Kubernetes で Progressive Delivery を実現するには下記のソフトウェアを用いる事が可能です。 また今回の手順は MacOS を前提に記します。
Argo Rollouts Prometheus Istio Kubernetes (今回は Minikube を使いました) 事前の準備 Istio Istio をダウンロードします。
curl -L https://istio.io/downloadIstio | ISTIO_VERSION=17.2 sh - Istio を Minikube にデプロイします。
cd istio-17.2 istioctl install --set profile=demo -y Kubernetes Namespace default で起動した Pod が自動的に Envoy サイドカーを取得するように設定します。...</p>
  </section>
  <footer class="entry-footer">&lt;span title=&#39;2023-06-03 05:55:09 &#43;0900 JST&#39;&gt;June 3, 2023&lt;/span&gt;&amp;nbsp;·&amp;nbsp;4 min&amp;nbsp;·&amp;nbsp;Theme PaperMod</footer>
  <a class="entry-link" aria-label="post link to 手軽にローカルで Argo Rollouts, Istio, Prometheus で Progressive Delivery を試す" href="https://jedipunkz.github.io/post/argo-rollout-progressive-delivery/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>自前ツールと Cloudwatch 高解像度メトリクスを使ったより高速な ECS オートスケールの実現
    </h2>
  </header>
  <section class="entry-content">
    <p>こんにちは @jedipunkz 🚀 です。
普段仕事で AWS ECS を使っていて Autoscallng Group によってアプリケーションを据えケールさせて運用していますが、運用している中でより高速にオートスケール出来ないものだろうか？と思うシチュエーションが何回か発生し、対応方法について模索していました。
実際に発生したシチュエーション 下記はコンテナ毎の CPU 使用率です。1分未満の間に急激にアクセスが増えコンテナの CPU 使用率が 100% に達し (実際には vCPU に基づいて 200% となっている)、ECS Service のヘルスチェックに Fail して、コンテナが落ち、新しいコンテナは起動するものの、アクセス不可に耐えられず、コンテナ停止と起動を繰り返すといった状況でした。
Autoscaling Policy, Cloudwatch Metrics Alarm の調整 まず最初に考えたのが下記の値の調整です。
aws_app_autoscaling_policy の cooldown 値 aws_cloudwatch_metric_alarm の period 値 具体的には 60sec となっていた値を 10sec などに変更しました。これによって 60sec のインターバルでしきい値計算してスケールさせていたところを 10sec にインターバルを縮めつつスケールさせる。つまりより迅速にスケールさせることで上記のシチュエーションに耐えられるのではと考えました。
ですが、結果は NG でした。
下記は Cloudwatch Metrics の様子です。データはプロットされているものの、データ不足 という状態に陥っている事がわかります。
実際に ECS はこの設定をした Metrics Alarm ではスケールしてくれませんでした。
高解像度メトリクスの利用について であれば高解像度メトリクス を利用すれば良いのではと考えました。
歴史的に...</p>
  </section>
  <footer class="entry-footer">&lt;span title=&#39;2023-03-24 14:54:11 &#43;0900 JST&#39;&gt;March 24, 2023&lt;/span&gt;&amp;nbsp;·&amp;nbsp;2 min&amp;nbsp;·&amp;nbsp;Theme PaperMod</footer>
  <a class="entry-link" aria-label="post link to 自前ツールと Cloudwatch 高解像度メトリクスを使ったより高速な ECS オートスケールの実現" href="https://jedipunkz.github.io/post/esp/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>Sysdig&#43;ECS Fargate でコンテナランタイムセキュリティ実践
    </h2>
  </header>
  <section class="entry-content">
    <p>こんにちは @jedipunkz 🚀 です。
ECS 構成をもう少しセキュアに保てる構成はないものだろうかと模索しているなかで Sysdig を見つけました。まだ導入できる目処は立っていないのですがある程度ノウハウ蓄積出来てきたのでここで検証内容等を記事にしようかと思っています。
Sysdig は幾つかのサービスが存在するのですが今回検証したのは Sysdig Serverless Security と呼ばれるモノで ECS Fargate 上のコンテナランタイムセキュリティを実践することができるサービスです。
Sysdig とは AWS のサービスにも脅威検知を行うことができるサービスが揃っているのはご存知と思います
対象 目的 技術・サービス AWS リソース 驚異検知 AWS GuardDuty また予防の観点で脆弱性診断が出来るサービスもありあす
対象 目的 技術・サービス AWS リソース セキュリティ診断 AWS Trusted Advisor ECS コンテナ 脆弱性診断 ECR Image Scan EC2 上のソフトウェア 脆弱性診断 AWS Inspector ここで気がつくと思うのですがコンテナ上の驚異検知を行うサービスが AWS には無いと思っています。 (2022/09 時点)
Sysdig Serverless Security は ECS Fargate コンテナ上の脅威検知を行うサービスです。ECS Fargate 利用時にコンテナ上の脅威検知を行うサービスは他にも幾つかありますが、Sysdig はシステムコールを利用したコンテナランタイムセキュリティを実践して脅威検知・通知が行えるものになります。自分も詳しくないのですがこれを CWPP (Cloud Workload Protection Platform) と言うらしいです。ワークロードというのはクラウド上の仮想マシン・稼働中のソフトウェアを指して、CWPP はマルウェア保護、脆弱性スキャン、アクセス制御、異常検知の機能を使用してそれぞれのワークロードを保護する、ということらしいです。...</p>
  </section>
  <footer class="entry-footer">&lt;span title=&#39;2022-09-24 22:00:00 &#43;0900 JST&#39;&gt;September 24, 2022&lt;/span&gt;&amp;nbsp;·&amp;nbsp;4 min&amp;nbsp;·&amp;nbsp;Theme PaperMod</footer>
  <a class="entry-link" aria-label="post link to Sysdig&#43;ECS Fargate でコンテナランタイムセキュリティ実践" href="https://jedipunkz.github.io/post/sysdig-ecs-fargate/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>ECS &#43; PipeCD &#43; Datadog でプログレッシブデリバリーを実現
    </h2>
  </header>
  <section class="entry-content">
    <p>こんにちは @jedipunkz 🚀 です。
今回は CNCF にジョインした PipeCD と Datadog を用いて ECS 環境にてプログレッシブデリバリーを実現する方法について調査したので、その内容を記したいと思います。
そもそもプログレッシブデリバリーとは アプリケーションのデリバリー方法はカナリーリリースやブルーグリーンデプロイメント等がよく知られていると思います。プログレッシブデリバリーはその一歩先を行くデリバリー方式で、Prometheus や Datadog 等のメトリクスを用いて SLO (SRE の SLO と言うよりはデプロイのための指標という意味での) を元にカナリーリリースしたアプリケーションが期待した動作をしているかを確認し (プログレッシブデリバリー的にはこのフェーズを ANALYSIS という様です)、その上でカナリーリリースを完了するというフローになります。
構成 Pipecd, Piped 共に Kubernetes (EKS) クラスタ上に起動する構成 この検証ではこちらの構成を選択しました。この構成の特徴は
piped は pipecd の API エンドポイントを指し示す pipecd は UI を提供 pipecd は Filestore (S3, GCS, Minio など), Datastore (MySQL, Firestore など) を利用可 (今回は Minio, MySQL を選択) piped は Target Group, ECS タスク定義等の操作を行うため ECS API へのアクセス権限が必要 piped の pipeline 上のステージで ANALYSIS という Datadog 等のメトリクスを解析する機能を有している アプリケーションレポジトリには app....</p>
  </section>
  <footer class="entry-footer">&lt;span title=&#39;2022-08-10 09:11:04 &#43;0900 JST&#39;&gt;August 10, 2022&lt;/span&gt;&amp;nbsp;·&amp;nbsp;6 min&amp;nbsp;·&amp;nbsp;Theme PaperMod</footer>
  <a class="entry-link" aria-label="post link to ECS &#43; PipeCD &#43; Datadog でプログレッシブデリバリーを実現" href="https://jedipunkz.github.io/post/ecs-pipecd/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>ECR 脆弱性スキャン結果表示 CLI の開発と Datadog プロット
    </h2>
  </header>
  <section class="entry-content">
    <p>こんにちは。jedipunkz🚀 です。
引き続き Go を学習しています。前回の記事 ECS コンテナにログインする CLI を Go 言語で作った話 のまとめにも記したのですが Go のコードを書くアイデアとして下記をぼんやり考えていました。
ECR 脆弱性スキャンのパッケージを開発 そのパッケージを利用して Datadog のカスタムメトリクスとして送信 同様にそのパッケージを利用して ECR スキャンの CLI を作成 その紹介を軽くしたいと思います。
開発した ECR 脆弱性スキャンの Go パッケージ 開発したパッケージは https://github.com/jedipunkz/ecrscan になります。
下記のように Ecr 構造体を初期化します。
e := myecr.Ecr{} e.Repositories = [][]string{ {&#34;image-to-scan&#34;, &#34;latest&#34;}, } e.Resion = &#34;ap-northeast-1&#34; finding, vulFindings, _ := e.ListFindings() その後 ListFindings() メソッドでスキャンします。結果、finding.FindingSeverityCounts には下記の深刻度毎のイメージに含まれている脆弱性の数が入ります。
INFORMATIONAL LOW MEDIUM HIGH CRITICAL UNDEFINED また、vulFindings には含まれている脆弱性の
CVE 名 深刻度レベル (INFORMATIONAL, LOW, MEDIUM, HIGH, CRITICAL, UNDEFINED) CVE URI 説明 が入ります。...</p>
  </section>
  <footer class="entry-footer">&lt;span title=&#39;2022-04-30 13:56:56 &#43;0900 JST&#39;&gt;April 30, 2022&lt;/span&gt;&amp;nbsp;·&amp;nbsp;2 min&amp;nbsp;·&amp;nbsp;Theme PaperMod</footer>
  <a class="entry-link" aria-label="post link to ECR 脆弱性スキャン結果表示 CLI の開発と Datadog プロット" href="https://jedipunkz.github.io/post/ecr-scan-datadog-go/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2>ECS コンテナにログインする CLI を Go 言語で作った話
    </h2>
  </header>
  <section class="entry-content">
    <p>こんにちは @jedipunkz 🚀 です。
今回は Go 言語で ECS コンテナにログインする CLI を作った話を書きます。
開発の経緯 自分はまだ Go 言語の初学者で学習のために開発するアイデアを探していた状態でした。そこで自分の勤めている会社で ECS Execute 機能を使ったコンテナログインの機能を開発者に提供していた事を思い出し色々調べていて「もう少し手間が省けないか？」と思い立った、という経緯で開発をはじめました。
awscli を使った ECS Execute 機能によるコンテナログイン 手間が多いと書きましたが実際に awscli を使う場合どの程度の手間があるのか簡単に記します。まず下記のコマンドを実行して
$ aws ecs list-tasks --cluster &lt;クラスタ名&gt; --service &lt;サービス名&gt; taskArn が得られるので Arn から task ID を拾って、その task ID を使って
$ aws ecs execute --cluster &lt;クラスタ名&gt; \ --task &lt;task ID&gt; \ -- container &lt;コンテナ名&gt; \ --interfactive \ --command &#34;sh&#34; とコマンドを実行することでコンテナにログイン出来ます。が手間が少し多いのと task ID を拾い出す作業も辛いので改善したい…。
操作画面 ということで miniecs という CLI を作ったのですが、 まずは操作している様子を貼り付けます。😷 Fuzzy Finder なインクリメンタルサーチが出来る CLI になっていて、ECS クラスタ名・ECS サービス名・コンテナ名を一部入力するとログインしたい環境が選択出来るツールになっています。...</p>
  </section>
  <footer class="entry-footer">&lt;span title=&#39;2022-02-05 00:00:27 &#43;0900 JST&#39;&gt;February 5, 2022&lt;/span&gt;&amp;nbsp;·&amp;nbsp;2 min&amp;nbsp;·&amp;nbsp;Theme PaperMod</footer>
  <a class="entry-link" aria-label="post link to ECS コンテナにログインする CLI を Go 言語で作った話" href="https://jedipunkz.github.io/post/ecs-login-cli/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://jedipunkz.github.io/post/page/2/">Next Page »</a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://jedipunkz.github.io">jedipunkz 🚀 のブログ</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
