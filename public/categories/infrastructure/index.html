<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>infrastructure | jedipunkz 🚀 のブログ</title>
<meta name="keywords" content="">
<meta name="description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod">
<meta name="author" content="Theme PaperMod">
<link rel="canonical" href="https://jedipunkz.github.io/categories/infrastructure/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.82449a0ebc78ea33ea224706d0fd9fe688cf7c1aaf651502338cd7992a8fa229.css" integrity="sha256-gkSaDrx46jPqIkcG0P2f5ojPfBqvZRUCM4zXmSqPoik=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://jedipunkz.github.io/pix/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://jedipunkz.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://jedipunkz.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://jedipunkz.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://jedipunkz.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://jedipunkz.github.io/categories/infrastructure/index.xml">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-30563095-1', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="infrastructure" />
<meta property="og:description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://jedipunkz.github.io/categories/infrastructure/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="infrastructure"/>
<meta name="twitter:description" content="Theme PaperMod - https://github.com/adityatelange/hugo-PaperMod"/>

</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://jedipunkz.github.io" accesskey="h" title="jedipunkz 🚀 のブログ (Alt + H)">jedipunkz 🚀 のブログ</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://jedipunkz.github.io/about" title="About Me">
                    <span>About Me</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    infrastructure
  </h1>
</header>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>自前ツールと Cloudwatch 高解像度メトリクスを使ったより高速な ECS オートスケールの実現
    </h2>
  </header>
  <div class="entry-content">
    <p>こんにちは @jedipunkz 🚀 です。
普段仕事で AWS ECS を使っていて Autoscallng Group によってアプリケーションを据えケールさせて運用していますが、運用している中でより高速にオートスケール出来ないものだろうか？と思うシチュエーションが何回か発生し、対応方法について模索していました。
実際に発生したシチュエーション 下記はコンテナ毎の CPU 使用率です。1分未満の間に急激にアクセスが増えコンテナの CPU 使用率が 100% に達し (実際には vCPU に基づいて 200% となっている)、ECS Service のヘルスチェックに Fail して、コンテナが落ち、新しいコンテナは起動するものの、アクセス不可に耐えられず、コンテナ停止と起動を繰り返すといった状況でした。
Autoscaling Policy, Cloudwatch Metrics Alarm の調整 まず最初に考えたのが下記の値の調整です。
aws_app_autoscaling_policy の cooldown 値 aws_cloudwatch_metric_alarm の period 値 具体的には 60sec となっていた値を 10sec などに変更しました。これによって 60sec のインターバルでしきい値計算してスケールさせていたところを 10sec にインターバルを縮めつつスケールさせる。つまりより迅速にスケールさせることで上記のシチュエーションに耐えられるのではと考えました。
ですが、結果は NG でした。
下記は Cloudwatch Metrics の様子です。データはプロットされているものの、データ不足 という状態に陥っている事がわかります。
実際に ECS はこの設定をした Metrics Alarm ではスケールしてくれませんでした。
高解像度メトリクスの利用について であれば高解像度メトリクス を利用すれば良いのではと考えました。
歴史的に...</p>
  </div>
  <footer class="entry-footer"><span title='2023-03-24 14:54:11 +0900 JST'>March 24, 2023</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Theme PaperMod</footer>
  <a class="entry-link" aria-label="post link to 自前ツールと Cloudwatch 高解像度メトリクスを使ったより高速な ECS オートスケールの実現" href="https://jedipunkz.github.io/post/esp/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Sysdig&#43;ECS Fargate でコンテナランタイムセキュリティ実践
    </h2>
  </header>
  <div class="entry-content">
    <p>こんにちは @jedipunkz 🚀 です。
ECS 構成をもう少しセキュアに保てる構成はないものだろうかと模索しているなかで Sysdig を見つけました。まだ導入できる目処は立っていないのですがある程度ノウハウ蓄積出来てきたのでここで検証内容等を記事にしようかと思っています。
Sysdig は幾つかのサービスが存在するのですが今回検証したのは Sysdig Serverless Security と呼ばれるモノで ECS Fargate 上のコンテナランタイムセキュリティを実践することができるサービスです。
Sysdig とは AWS のサービスにも脅威検知を行うことができるサービスが揃っているのはご存知と思います
対象 目的 技術・サービス AWS リソース 驚異検知 AWS GuardDuty また予防の観点で脆弱性診断が出来るサービスもありあす
対象 目的 技術・サービス AWS リソース セキュリティ診断 AWS Trusted Advisor ECS コンテナ 脆弱性診断 ECR Image Scan EC2 上のソフトウェア 脆弱性診断 AWS Inspector ここで気がつくと思うのですがコンテナ上の驚異検知を行うサービスが AWS には無いと思っています。 (2022/09 時点)
Sysdig Serverless Security は ECS Fargate コンテナ上の脅威検知を行うサービスです。ECS Fargate 利用時にコンテナ上の脅威検知を行うサービスは他にも幾つかありますが、Sysdig はシステムコールを利用したコンテナランタイムセキュリティを実践して脅威検知・通知が行えるものになります。自分も詳しくないのですがこれを CWPP (Cloud Workload Protection Platform) と言うらしいです。ワークロードというのはクラウド上の仮想マシン・稼働中のソフトウェアを指して、CWPP はマルウェア保護、脆弱性スキャン、アクセス制御、異常検知の機能を使用してそれぞれのワークロードを保護する、ということらしいです。...</p>
  </div>
  <footer class="entry-footer"><span title='2022-09-24 22:00:00 +0900 JST'>September 24, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Theme PaperMod</footer>
  <a class="entry-link" aria-label="post link to Sysdig&#43;ECS Fargate でコンテナランタイムセキュリティ実践" href="https://jedipunkz.github.io/post/sysdig-ecs-fargate/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>ECS &#43; PipeCD &#43; Datadog でプログレッシブデリバリーを実現
    </h2>
  </header>
  <div class="entry-content">
    <p>こんにちは @jedipunkz 🚀 です。
今回は CNCF にジョインした PipeCD と Datadog を用いて ECS 環境にてプログレッシブデリバリーを実現する方法について調査したので、その内容を記したいと思います。
そもそもプログレッシブデリバリーとは アプリケーションのデリバリー方法はカナリーリリースやブルーグリーンデプロイメント等がよく知られていると思います。プログレッシブデリバリーはその一歩先を行くデリバリー方式で、Prometheus や Datadog 等のメトリクスを用いて SLO (SRE の SLO と言うよりはデプロイのための指標という意味での) を元にカナリーリリースしたアプリケーションが期待した動作をしているかを確認し (プログレッシブデリバリー的にはこのフェーズを ANALYSIS という様です)、その上でカナリーリリースを完了するというフローになります。
構成 Pipecd, Piped 共に Kubernetes (EKS) クラスタ上に起動する構成 この検証ではこちらの構成を選択しました。この構成の特徴は
piped は pipecd の API エンドポイントを指し示す pipecd は UI を提供 pipecd は Filestore (S3, GCS, Minio など), Datastore (MySQL, Firestore など) を利用可 (今回は Minio, MySQL を選択) piped は Target Group, ECS タスク定義等の操作を行うため ECS API へのアクセス権限が必要 piped の pipeline 上のステージで ANALYSIS という Datadog 等のメトリクスを解析する機能を有している アプリケーションレポジトリには app....</p>
  </div>
  <footer class="entry-footer"><span title='2022-08-10 09:11:04 +0900 JST'>August 10, 2022</span>&nbsp;·&nbsp;6 min&nbsp;·&nbsp;Theme PaperMod</footer>
  <a class="entry-link" aria-label="post link to ECS &#43; PipeCD &#43; Datadog でプログレッシブデリバリーを実現" href="https://jedipunkz.github.io/post/ecs-pipecd/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>ECR 脆弱性スキャン結果表示 CLI の開発と Datadog プロット
    </h2>
  </header>
  <div class="entry-content">
    <p>こんにちは。jedipunkz🚀 です。
引き続き Go を学習しています。前回の記事 ECS コンテナにログインする CLI を Go 言語で作った話 のまとめにも記したのですが Go のコードを書くアイデアとして下記をぼんやり考えていました。
ECR 脆弱性スキャンのパッケージを開発 そのパッケージを利用して Datadog のカスタムメトリクスとして送信 同様にそのパッケージを利用して ECR スキャンの CLI を作成 その紹介を軽くしたいと思います。
開発した ECR 脆弱性スキャンの Go パッケージ 開発したパッケージは https://github.com/jedipunkz/ecrscan になります。
下記のように Ecr 構造体を初期化します。
e := myecr.Ecr{} e.Repositories = [][]string{ {&#34;image-to-scan&#34;, &#34;latest&#34;}, } e.Resion = &#34;ap-northeast-1&#34; finding, vulFindings, _ := e.ListFindings() その後 ListFindings() メソッドでスキャンします。結果、finding.FindingSeverityCounts には下記の深刻度毎のイメージに含まれている脆弱性の数が入ります。
INFORMATIONAL LOW MEDIUM HIGH CRITICAL UNDEFINED また、vulFindings には含まれている脆弱性の
CVE 名 深刻度レベル (INFORMATIONAL, LOW, MEDIUM, HIGH, CRITICAL, UNDEFINED) CVE URI 説明 が入ります。...</p>
  </div>
  <footer class="entry-footer"><span title='2022-04-30 13:56:56 +0900 JST'>April 30, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Theme PaperMod</footer>
  <a class="entry-link" aria-label="post link to ECR 脆弱性スキャン結果表示 CLI の開発と Datadog プロット" href="https://jedipunkz.github.io/post/ecr-scan-datadog-go/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>ECS コンテナにログインする CLI を Go 言語で作った話
    </h2>
  </header>
  <div class="entry-content">
    <p>こんにちは @jedipunkz 🚀 です。
今回は Go 言語で ECS コンテナにログインする CLI を作った話を書きます。
開発の経緯 自分はまだ Go 言語の初学者で学習のために開発するアイデアを探していた状態でした。そこで自分の勤めている会社で ECS Execute 機能を使ったコンテナログインの機能を開発者に提供していた事を思い出し色々調べていて「もう少し手間が省けないか？」と思い立った、という経緯で開発をはじめました。
awscli を使った ECS Execute 機能によるコンテナログイン 手間が多いと書きましたが実際に awscli を使う場合どの程度の手間があるのか簡単に記します。まず下記のコマンドを実行して
$ aws ecs list-tasks --cluster &lt;クラスタ名&gt; --service &lt;サービス名&gt; taskArn が得られるので Arn から task ID を拾って、その task ID を使って
$ aws ecs execute --cluster &lt;クラスタ名&gt; \ --task &lt;task ID&gt; \ -- container &lt;コンテナ名&gt; \ --interfactive \ --command &#34;sh&#34; とコマンドを実行することでコンテナにログイン出来ます。が手間が少し多いのと task ID を拾い出す作業も辛いので改善したい…。
操作画面 ということで miniecs という CLI を作ったのですが、 まずは操作している様子を貼り付けます。😷 Fuzzy Finder なインクリメンタルサーチが出来る CLI になっていて、ECS クラスタ名・ECS サービス名・コンテナ名を一部入力するとログインしたい環境が選択出来るツールになっています。...</p>
  </div>
  <footer class="entry-footer"><span title='2022-02-05 00:00:27 +0900 JST'>February 5, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Theme PaperMod</footer>
  <a class="entry-link" aria-label="post link to ECS コンテナにログインする CLI を Go 言語で作った話" href="https://jedipunkz.github.io/post/ecs-login-cli/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>App Mesh と ECS によるカナリーリリース構成を検証してみた
    </h2>
  </header>
  <div class="entry-content">
    <p>こんにちは。jedipunkz🚀 です。
今回も READYFOR Advent Calendar 2021 の記事として執筆します。
今回のテーマ 前回の記事 では ECS 移行後の構成について検討する内容を記しました。Progressive Delivery を実践する上でもその一歩手前の構成と言っていいカナリーリリース構成について、今回は記していきたいと思います。
デグレしてしまっていたカナリーリリース READYFOR では AWS ECS 移行を行い ECS &#43; CodeDeploy による Blue/Green デプロイメントを導入しました。逆に移行前までに出来ていたカナリーリリースが実施できなくなりました。とは言ってもそれまで開発者がカナリーリリースに対して求めていた主な機能はロールバックだったため、ひとまずは Blue/Green デプロイメントで事足りている状況なのですが、今後大きな機能をリリースする際にはトラヒックを徐々に寄せ影響を把握した上でリリース進めるという作業は必要になってくる可能性があります。
よって、
Progressive Delivery の一歩手前の構成を実践する 大きなリリースのための環境整備 という意味でも、一回カナリーリリース構成について検討しておこうと考えました。
環境構築 今回用意した Terraform コード 検証で作成した AWS 環境をデプロイするための Terraform コードを下記の場所に置いてあります。参考にしてください。
https://github.com/jedipunkz/tf-appmesh-ecs-canary-release
(今回検証で作成したコードは業務上作成したものですが、READYFOR の OSS ポリシーに則り著作権譲渡をうけており、自らのGitHubリポジトリで公開しています。)
App Mesh ECS NLB Service Discovery Envoy X-Ray といった技術要素で構成されています。
Terraform コードによるデプロイ実施 上記に記した Terraform コードを使った構成のデプロイ手順を記します。
前提として Terraform バージョン 1.0.x 系以上をローカルにインストールする必要があります。
$ # AWS クレデンシャル情報を設定 $ git clone https://github....</p>
  </div>
  <footer class="entry-footer"><span title='2021-12-10 13:56:56 +0900 JST'>December 10, 2021</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Theme PaperMod</footer>
  <a class="entry-link" aria-label="post link to App Mesh と ECS によるカナリーリリース構成を検証してみた" href="https://jedipunkz.github.io/post/app-mesh-ecs-canary/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>ECS 以後の構成と Progressive Delivery の調査
    </h2>
  </header>
  <div class="entry-content">
    <p>こんにちは。jedipunkz です。
今回は READYFOR Advent Calendar 2021 の記事として執筆します。
READYFOR では 2021 年の夏に AWS ECS へプラットフォーム移行をしました。ECS は自分達の要件を全て満たしてくれ運用コストも極小化できて更に周辺の技術も AWS 公式のものが揃っているので、とても満足している状況です。
移行を終えたばかりなので「では次のアーキテクチャは？」という話にはまだなっていないのですが、今は準備期間として余裕を持ってスケジューリングできる状態にして頂いているので、SRE チームとしては色々な技術をリサーチしている段階になります。
今現在は ECS &#43; CodeDeploy を使って Blue/Green デプロイメントを実現しているのですが、よりモダンなデプロイ方式 Progressive Delivery について去年あたりから興味を持っていました。ただ、今までは実際に技術を触るまでには至っていなかったのでこの機会に色々と触ってみたという次第です。
今までも Blue/Green デプロイメント, Canary リリースとデプロイ方式が複数ありましたが、これらを含む継続的デリバリの次のステップと言われているのが Progressive Delivery です。2020年に Hashicorp 社の Mitchell Hashimoto 氏 が来日した際に「今一番気になっているワード」としてあげていましたのが印象的でした。
ECS を使った Canary リリース Progressive Delivery の話をする前に ECS を使った Canary リリースについて少し触れておきます。 (具体的な話についても、どこかのタイミングで記事にできればと思っています)
AWS App Mesh と ECS, X-Ray を使って下記のような構成を作りました。この構成中の App Mesh の Virtual Router のルーティング情報を修正する形で Canary リリースのトラヒック操作が行えます。ECS 以前は Canary リリースを実現できていて ECS 導入によってそれがデグレした状態だったので、この構成の検証は一つの成果だったと思っていますし、今回話をする Progressive Delivery のひとつ前のステップとも考えています。...</p>
  </div>
  <footer class="entry-footer"><span title='2021-11-11 17:28:46 +0900 JST'>November 11, 2021</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Theme PaperMod</footer>
  <a class="entry-link" aria-label="post link to ECS 以後の構成と Progressive Delivery の調査" href="https://jedipunkz.github.io/post/progressive_delivery/"></a>
</article>

<article class="post-entry tag-entry"> 
  <header class="entry-header">
    <h2>Go 言語と awscli を使って ECS/Fargate 上でコマンド実行してみた
    </h2>
  </header>
  <div class="entry-content">
    <p>こんにちは @jedipunkz 🚀 です。
最近、職場では ECS/Fargate でサービスを運用しています。そこで ECS Task 上でコマンドを実行する必要に迫られて幾つか調べたのですが、複数の方法があり検証をしてみました。これには 2021/03 にリリースされたばかりの ECS 上のコンテナでコマンドを実行する機能も含まれています。
自分たちは自動化する必要があったので Go 言語 (aws-sdk-go) を中心に検証実施しましたが同時に awscli でも動作検証しましたので、その方法をこの記事に記そうかと思います。
下記の2つの ECS の機能についてそれぞれ Go 言語, awscli で動作検証実施しました。
(1) ECS Execute Command (2021/03 リリース) (2) ECS Run Task 用いるツール類 下記のツールを前提に記事を記します。
aws-sdk-go Terraform awscli 共通で必要な taskRoleArn まず Task Definition に対して executeRoleArn とは別に TaskRoleArn の付与が必要になります。
resource &#34;aws_ecs_task_definition&#34; &#34;sample&#34; { family = &#34;sample&#34; cpu = &#34;256&#34; memory = &#34;512&#34; network_mode = &#34;awsvpc&#34; requires_compatibilities = [&#34;FARGATE&#34;] execution_role_arn = module....</p>
  </div>
  <footer class="entry-footer"><span title='2021-04-13 18:35:36 +0900 JST'>April 13, 2021</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Theme PaperMod</footer>
  <a class="entry-link" aria-label="post link to Go 言語と awscli を使って ECS/Fargate 上でコマンド実行してみた" href="https://jedipunkz.github.io/post/ecs-execute-command/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://jedipunkz.github.io/categories/infrastructure/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://jedipunkz.github.io">jedipunkz 🚀 のブログ</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
